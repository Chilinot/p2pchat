\begin{frame}
  \frametitle{Introduction}
  \begin{itemize}
    \item \textbf{What is P2PChat?}\\
      % It is a chat program that uses peer-to-peer connections in order to create a large network containing all clients connected to a large group chat.
      % It currently only supports a single global group chat.
      % Smaller groupchats can be created by creating new networks.
      Chat program which utilizes peer-to-peer connections in order to construct a large network of clients whom all participate in a single global group chat.
    \item \textbf{How does it work?}
      \begin{itemize}
        \item Clients connect to each other and create a network.
        \item Clients can then broadcast messages over the network.
        \item No tracker sadly; clients have to manually connect to each other.
      \end{itemize}
  \end{itemize}
  % What is P2Pchat?
  % How does it work?
  % GRAPH
\end{frame}

\begin{frame}
  \frametitle{Example Network}
  \begin{figure}
    \centering
    \import{figures/}{example_network.tikz}
  \end{figure}

  Five clients connected to each other forming a simple network. If client $5$ broadcasts a message, it will traverse the entire graph and eventually reach all nodes in the network.
\end{frame}

\begin{frame}
  \frametitle{Application Structure}
  \begin{figure}
    % Scale vector image
    \def\svgwidth{\textwidth}
    % Import vector file generated by inkscape (needs "import" package)
    \import{figures/}{p2pchat_structure.pdf_tex}
  \end{figure}
\end{frame}

\begin{frame}
  \frametitle{Application Structure}
  \begin{figure}
    % Scale vector image
    \def\svgwidth{0.7\textwidth}
    % Import vector file generated by inkscape (needs "import" package)
    \import{figures/}{p2pchat_structure.pdf_tex}
  \end{figure}

  \begin{itemize}
    \item<2-> Rounded rectangles represents actors.
    \item<3-> Arrows inside big rectangle represents channels.
    \item<4-> Arrows outside represents TCP sockets.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Application Structure}
  The program consists of three main parts:
  \begin{itemize}
    \item<2-> Actor Manager
      \begin{itemize}
        \item<5-> Manages a list of connected clients and their associated actors.
        \item<6-> Broadcasts incoming messages to all connected clients.
        \item<7-> Essentially the main hub of the program.
      \end{itemize}

    \item<3-> Connection Listener
      \begin{itemize}
        \item<8-> Listens for new TCP connections.
        \item<9-> Upon a new connection it does three things:
          \begin{enumerate}
            \item<10-> Spawns two new actors that separately read/write to/from the socket.
            \item<11-> Creates new channels between the Actor Manager and the two new actors.
            \item<12-> Notifies the Actor Manager by sending it a message containing a new Client object.
          \end{enumerate}
      \end{itemize}

    \item<4-> A Connection
      \begin{itemize}
        \item<13-> An abstract concept. Each connection is represented by the two actors spawned by the Connection Listener.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why Rust?}
  % Why did i choose Rust over other lanugages?
  % - Wanted to learn the language.
  % - Very safe memory management
  % - - Forces you to reason about memory ownership
  % - - Does not allow sharing of memory between threads unless boxed in safe wrappers
  % - - - Good for actor model
  % - - - Have to use channels in order to pass data (memory ownership) between threads
  % - Multi paradigm language, has functional syntax, as well as imperative
  % - - Pattern matching
  % - - Object oriented
  % - Compiles to LLVM
  % - - Allows the developer to utilize all the goodies from LLVM such a bunch of optimizations
  % - - Allows the developer to compile binaries for a lot of architectures
  % - Integrates well with other languages that support the C ABI.
  % - - Can even write inline assembly
  \begin{itemize}
    \item \textbf{Why Rust instead of any other language?}\\
      \begin{itemize}
        \item<2-> Forces me to reason about memory ownership.
          \begin{itemize}
            \item<3-> Only one scope can own and use a reference at any given time.
          \end{itemize}
        \item<4-> Automatic memory management without the need of a garbage collector.
        \item<5-> Guarantees memory safety.
        \item<6-> Guarantees no data races.
          \begin{itemize}
            \item<7-> Does so by not allowing any threads to share data.\footnotemark
            \item<8-> Need to use channels in order to pass data between threads.
          \end{itemize}
        \item<9-> Compiles to LLVM, and has a minimal runtime.
          \begin{itemize}
            \item<10-> Can essentially run on any hardware.
          \end{itemize}
      \end{itemize}
  \end{itemize}

  \footnotetext{Threads can share data, but under very strict conditions.}
\end{frame}
